require "../support"

solve do
  test <<-INPUT, 21
    .......S.......
    ...............
    .......^.......
    ...............
    ......^.^......
    ...............
    .....^.^.^.....
    ...............
    ....^.^...^....
    ...............
    ...^.^...^.^...
    ...............
    ..^...^.....^..
    ...............
    .^.^.^.^.^...^.
    ...............
    INPUT

  answer do |input|
    grid = input.lines
    beam = [grid[0].index!('S')]

    count = 0
    (2...grid.size).step(2) do |y|
      beam = beam.flat_map do |x|
        if grid[y][x] == '^'
          count += 1
          [x - 1, x + 1]
        else
          [x]
        end
      end.uniq!
    end
    count
  end
end

m_solve do
  m_test <<-INPUT, 21
    .......S.......
    ...............
    .......^.......
    ...............
    ......^.^......
    ...............
    .....^.^.^.....
    ...............
    ....^.^...^....
    ...............
    ...^.^...^.^...
    ...............
    ..^...^.....^..
    ...............
    .^.^.^.^.^...^.
    ...............
    INPUT

  m_answer do |input|
    grid = input.lines.reject(&.=~(/^\.+$/)).map(&.chars)
    beam = [M::Array::Index.call(grid[0], 'S')]

    count = 0
    (1...grid.size).each do |y|
      beam2 = [] of _
      beam.each do |x|
        if grid[y][x] == '^'
          count += 1
          beam2 << x - 1 << x + 1
        else
          beam2 << x
        end
      end
      beam = beam2.uniq
    end
    count
  end
end

solve do
  test <<-INPUT, 40
    .......S.......
    ...............
    .......^.......
    ...............
    ......^.^......
    ...............
    .....^.^.^.....
    ...............
    ....^.^...^....
    ...............
    ...^.^...^.^...
    ...............
    ..^...^.....^..
    ...............
    .^.^.^.^.^...^.
    ...............
    INPUT

  answer do |input|
    grid = input.lines
    beam = Array.new(grid[0].size) { |x| grid[0][x] == 'S' ? 1_i64 : 0_i64 }

    (2...grid.size).step(2) do |y|
      beam2 = Array.new(grid[0].size, 0_i64)
      beam.each_with_index do |c, x|
        if grid[y][x] == '^'
          beam2[x - 1] += c
          beam2[x + 1] += c
        else
          beam2[x] += c
        end
      end
      beam = beam2
    end

    beam.sum
  end
end

m_solve do
  m_test <<-INPUT, 40_i64
    .......S.......
    ...............
    .......^.......
    ...............
    ......^.^......
    ...............
    .....^.^.^.....
    ...............
    ....^.^...^....
    ...............
    ...^.^...^.^...
    ...............
    ..^...^.....^..
    ...............
    .^.^.^.^.^...^.
    ...............
    INPUT

  m_answer do |input|
    grid = input.lines.reject(&.=~(/^\.+$/)).map(&.chars)
    beam = grid[0].map { |ch| ch == 'S' ? 1_i64 : 0_i64 }

    (1...grid.size).each do |y|
      beam2 = beam.map { 0_i64 }
      beam.each_with_index do |c, x|
        if grid[y][x] == '^'
          beam2[x - 1] += c
          beam2[x + 1] += c
        else
          beam2[x] += c
        end
      end
      beam = beam2
    end

    M::Array::Sum.call(beam, nil, nil)
  end
end
